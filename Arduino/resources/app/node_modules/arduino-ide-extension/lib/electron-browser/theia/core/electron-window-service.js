"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ElectronWindowService = void 0;
const remote = require("@theia/core/electron-shared/@electron/remote");
const electron_1 = require("@theia/core/electron-shared/electron");
const connection_status_service_1 = require("@theia/core/lib/browser/connection-status-service");
const common_1 = require("@theia/core/lib/common");
const promise_util_1 = require("@theia/core/lib/common/promise-util");
const electron_window_service_1 = require("@theia/core/lib/electron-browser/window/electron-window-service");
const electron_messages_1 = require("@theia/core/lib/electron-common/messaging/electron-messages");
const inversify_1 = require("@theia/core/shared/inversify");
const electron_main_window_service_ext_1 = require("../../../electron-common/electron-main-window-service-ext");
let ElectronWindowService = class ElectronWindowService extends electron_window_service_1.ElectronWindowService {
    init() {
        // NOOP
        // Does not listen on Theia's `window.zoomLevel` changes.
        // TODO: IDE2 must switch to the Theia preferences and drop the custom one.
    }
    shouldUnload() {
        const offline = this.connectionStatusService.currentStatus === connection_status_service_1.ConnectionStatus.OFFLINE;
        const detail = offline
            ? common_1.nls.localize('arduino/electron/couldNotSave', 'Could not save the sketch. Please copy your unsaved work into your favorite text editor, and restart the IDE.')
            : common_1.nls.localize('arduino/electron/unsavedChanges', 'Any unsaved changes will not be saved.');
        const electronWindow = remote.getCurrentWindow();
        const response = remote.dialog.showMessageBoxSync(electronWindow, {
            type: 'question',
            buttons: [
                common_1.nls.localize('vscode/extensionsUtils/yes', 'Yes'),
                common_1.nls.localize('vscode/extensionsUtils/no', 'No'),
            ],
            title: common_1.nls.localize('vscode/Default/ConfirmTitle', 'Confirm'),
            message: common_1.nls.localize('arduino/sketch/close', 'Are you sure you want to close the sketch?'),
            detail,
        });
        return response === 0; // 'Yes', close the window.
    }
    async isFirstWindow() {
        if (this._firstWindow === undefined) {
            this._firstWindow = new promise_util_1.Deferred();
            const windowId = remote.getCurrentWindow().id; // This is expensive and synchronous so we check it once per FE.
            this.mainWindowServiceExt
                .isFirstWindow(windowId)
                .then((firstWindow) => { var _a; return (_a = this._firstWindow) === null || _a === void 0 ? void 0 : _a.resolve(firstWindow); });
        }
        return this._firstWindow.promise;
    }
    // Overridden because the default Theia implementation destroys the additional properties of the `options` arg, such as `tasks`.
    openNewWindow(url, options) {
        return this.delegate.openNewWindow(url, options);
    }
    // Overridden to support optional task owner params and make `tsc` happy.
    reload(options) {
        if ((options === null || options === void 0 ? void 0 : options.tasks) && options.tasks.length) {
            const { tasks } = options;
            electron_1.ipcRenderer.send(electron_messages_1.RELOAD_REQUESTED_SIGNAL, { tasks });
        }
        else {
            electron_1.ipcRenderer.send(electron_messages_1.RELOAD_REQUESTED_SIGNAL);
        }
    }
};
__decorate([
    (0, inversify_1.inject)(connection_status_service_1.ConnectionStatusService),
    __metadata("design:type", Object)
], ElectronWindowService.prototype, "connectionStatusService", void 0);
__decorate([
    (0, inversify_1.inject)(electron_main_window_service_ext_1.ElectronMainWindowServiceExt),
    __metadata("design:type", Object)
], ElectronWindowService.prototype, "mainWindowServiceExt", void 0);
__decorate([
    (0, inversify_1.postConstruct)(),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", []),
    __metadata("design:returntype", void 0)
], ElectronWindowService.prototype, "init", null);
ElectronWindowService = __decorate([
    (0, inversify_1.injectable)()
], ElectronWindowService);
exports.ElectronWindowService = ElectronWindowService;
//# sourceMappingURL=electron-window-service.js.map