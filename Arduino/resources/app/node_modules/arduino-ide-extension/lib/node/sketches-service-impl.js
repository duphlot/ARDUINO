"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SketchesServiceImpl = void 0;
const inversify_1 = require("@theia/core/shared/inversify");
const fs_1 = require("fs");
const os = require("os");
const temp = require("temp");
const path = require("path");
const glob = require("glob");
const crypto = require("crypto");
const PQueue = require("p-queue");
const ncp_1 = require("ncp");
const uri_1 = require("@theia/core/lib/common/uri");
const logger_1 = require("@theia/core/lib/common/logger");
const file_uri_1 = require("@theia/core/lib/node/file-uri");
const config_service_impl_1 = require("./config-service-impl");
const sketches_service_1 = require("../common/protocol/sketches-service");
const notification_service_server_1 = require("./notification-service-server");
const env_variables_1 = require("@theia/core/lib/common/env-variables");
const core_client_provider_1 = require("./core-client-provider");
const commands_pb_1 = require("./cli-protocol/cc/arduino/cli/commands/v1/commands_pb");
const promise_util_1 = require("@theia/core/lib/common/promise-util");
const service_error_1 = require("./service-error");
const is_temp_sketch_1 = require("./is-temp-sketch");
const path_1 = require("path");
const RecentSketches = 'recent-sketches.json';
const DefaultIno = `void setup() {
  // put your setup code here, to run once:

}

void loop() {
  // put your main code here, to run repeatedly:

}
`;
let SketchesServiceImpl = class SketchesServiceImpl extends core_client_provider_1.CoreClientAware {
    constructor() {
        super(...arguments);
        this.sketchSuffixIndex = 1;
        this.markAsRecentSketchQueue = new PQueue({
            autoStart: true,
            concurrency: 1,
        });
    }
    async getSketches({ uri }) {
        const root = await this.root(uri);
        const pathToAllSketchFiles = await new Promise((resolve, reject) => {
            glob('/!(libraries|hardware)/**/*.{ino,pde}', { root }, (error, results) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(results);
                }
            });
        });
        // Sort by path length to filter out nested sketches, such as the `Nested_folder` inside the `Folder` sketch.
        //
        // `directories#user`
        // |
        // +--Folder
        //    |
        //    +--Folder.ino
        //    |
        //    +--Nested_folder
        //       |
        //       +--Nested_folder.ino
        pathToAllSketchFiles.sort((left, right) => left.length - right.length);
        const container = sketches_service_1.SketchContainer.create(uri ? path.basename(root) : 'Sketchbook');
        const getOrCreateChildContainer = (parent, segments) => {
            if (segments.length === 1) {
                throw new Error(`Expected at least two segments relative path: ['ExampleSketchName', 'ExampleSketchName.{ino,pde}]. Was: ${segments}`);
            }
            if (segments.length === 2) {
                return parent;
            }
            const label = segments[0];
            const existingSketch = parent.sketches.find((sketch) => sketch.name === label);
            if (existingSketch) {
                // If the container has a sketch with the same label, it cannot have a child container.
                // See above example about how to ignore nested sketches.
                return undefined;
            }
            let child = parent.children.find((child) => child.label === label);
            if (!child) {
                child = sketches_service_1.SketchContainer.create(label);
                parent.children.push(child);
            }
            return child;
        };
        for (const pathToSketchFile of pathToAllSketchFiles) {
            const relative = path.relative(root, pathToSketchFile);
            if (!relative) {
                this.logger.warn(`Could not determine relative sketch path from the root <${root}> to the sketch <${pathToSketchFile}>. Skipping. Relative path was: ${relative}`);
                continue;
            }
            const segments = relative.split(path.sep);
            if (segments.length < 2) {
                // folder name, and sketch name.
                this.logger.warn(`Expected at least one segment relative path from the root <${root}> to the sketch <${pathToSketchFile}>. Skipping. Segments were: ${segments}.`);
                continue;
            }
            // the folder name and the sketch name must match. For example, `Foo/foo.ino` is invalid.
            // drop the folder name from the sketch name, if `.ino` or `.pde` remains, it's valid
            const sketchName = segments[segments.length - 2];
            const sketchFilename = segments[segments.length - 1];
            const sketchFileExtension = segments[segments.length - 1].replace(new RegExp(sketchName), '');
            if (sketchFileExtension !== '.ino' && sketchFileExtension !== '.pde') {
                this.logger.warn(`Mismatching sketch file <${sketchFilename}> and sketch folder name <${sketchName}>. Skipping`);
                continue;
            }
            const child = getOrCreateChildContainer(container, segments);
            if (child) {
                child.sketches.push({
                    name: sketchName,
                    uri: file_uri_1.FileUri.create(path.dirname(pathToSketchFile)).toString(),
                });
            }
        }
        return container;
    }
    async root(uri) {
        return file_uri_1.FileUri.fsPath(uri !== null && uri !== void 0 ? uri : (await this.sketchbookUri()));
    }
    async sketchbookUri() {
        const { sketchDirUri } = await this.configService.getConfiguration();
        return sketchDirUri;
    }
    async loadSketch(uri) {
        const { client, instance } = await this.coreClient;
        const req = new commands_pb_1.LoadSketchRequest();
        const requestSketchPath = file_uri_1.FileUri.fsPath(uri);
        req.setSketchPath(requestSketchPath);
        req.setInstance(instance);
        const stat = new promise_util_1.Deferred();
        (0, fs_1.lstat)(requestSketchPath, (err, result) => err ? stat.resolve(err) : stat.resolve(result));
        const sketch = await new Promise((resolve, reject) => {
            client.loadSketch(req, async (err, resp) => {
                if (err) {
                    let rejectWith = err;
                    if (isNotFoundError(err)) {
                        const invalidMainSketchFilePath = await isInvalidSketchNameError(err, requestSketchPath);
                        if (invalidMainSketchFilePath) {
                            rejectWith = sketches_service_1.SketchesError.InvalidName(err.details, file_uri_1.FileUri.create(invalidMainSketchFilePath).toString());
                        }
                        else {
                            rejectWith = sketches_service_1.SketchesError.NotFound(err.details, uri);
                        }
                    }
                    reject(rejectWith);
                    return;
                }
                const responseSketchPath = (0, is_temp_sketch_1.maybeNormalizeDrive)(resp.getLocationPath());
                if (requestSketchPath !== responseSketchPath) {
                    this.logger.warn(`Warning! The request sketch path was different than the response sketch path from the CLI. This could be a potential bug. Request: <${requestSketchPath}>, response: <${responseSketchPath}>.`);
                }
                const resolvedStat = await stat.promise;
                if (resolvedStat instanceof Error) {
                    this.logger.error(`The CLI could load the sketch from ${requestSketchPath}, but stating the folder has failed.`);
                    reject(resolvedStat);
                    return;
                }
                const { mtimeMs } = resolvedStat;
                resolve({
                    name: path.basename(responseSketchPath),
                    uri: file_uri_1.FileUri.create(responseSketchPath).toString(),
                    mainFileUri: file_uri_1.FileUri.create(resp.getMainFile()).toString(),
                    otherSketchFileUris: resp
                        .getOtherSketchFilesList()
                        .map((p) => file_uri_1.FileUri.create(p).toString()),
                    additionalFileUris: resp
                        .getAdditionalFilesList()
                        .map((p) => file_uri_1.FileUri.create(p).toString()),
                    rootFolderFileUris: resp
                        .getRootFolderFilesList()
                        .map((p) => file_uri_1.FileUri.create(p).toString()),
                    mtimeMs,
                });
            });
        });
        return sketch;
    }
    async maybeLoadSketch(uri) {
        return this._isSketchFolder(uri);
    }
    get recentSketchesFsPath() {
        return this.envVariableServer
            .getConfigDirUri()
            .then((uri) => path.join(file_uri_1.FileUri.fsPath(uri), RecentSketches));
    }
    async loadRecentSketches() {
        this.logger.debug(`>>> Loading recently opened sketches data.`);
        const fsPath = await this.recentSketchesFsPath;
        let data = {};
        try {
            const raw = await fs_1.promises.readFile(fsPath, {
                encoding: 'utf8',
            });
            try {
                data = JSON.parse(raw);
            }
            catch (err) {
                this.logger.error(`Could not parse recently opened sketches. Raw input was: ${raw}`);
            }
        }
        catch (err) {
            if ('code' in err && err.code === 'ENOENT') {
                this.logger.debug(`<<< '${RecentSketches}' does not exist yet. This is normal behavior. Falling back to empty data.`);
                return {};
            }
            throw err;
        }
        this.logger.debug(`<<< Successfully loaded recently opened sketches data: ${JSON.stringify(data)}`);
        return data;
    }
    async saveRecentSketches(data) {
        this.logger.debug(`>>> Saving recently opened sketches data: ${JSON.stringify(data)}`);
        const fsPath = await this.recentSketchesFsPath;
        await fs_1.promises.writeFile(fsPath, JSON.stringify(data, null, 2));
        this.logger.debug('<<< Successfully saved recently opened sketches data.');
    }
    async markAsRecentlyOpened(uri) {
        return this.markAsRecentSketchQueue.add(async () => {
            this.logger.debug(`Marking sketch at '${uri}' as recently opened.`);
            if (this.isTempSketch.is(file_uri_1.FileUri.fsPath(uri))) {
                this.logger.debug(`Sketch at '${uri}' is pointing to a temp location. Not marking as recently opened.`);
                return;
            }
            let sketch = undefined;
            try {
                sketch = await this.loadSketch(uri);
                this.logger.debug(`Loaded sketch ${JSON.stringify(sketch)} before marking it as recently opened.`);
            }
            catch (err) {
                if (sketches_service_1.SketchesError.NotFound.is(err) ||
                    sketches_service_1.SketchesError.InvalidName.is(err)) {
                    this.logger.debug(`Could not load sketch from '${uri}'. Not marking as recently opened.`);
                    return;
                }
                this.logger.error(`Unexpected error occurred while loading sketch from '${uri}'.`, err);
                throw err;
            }
            const data = await this.loadRecentSketches();
            const now = Date.now();
            this.logger.debug(`Marking sketch '${uri}' as recently opened with timestamp: '${now}'.`);
            data[sketch.uri] = now;
            let toDelete = undefined;
            if (Object.keys(data).length > 10) {
                let min = Number.MAX_SAFE_INTEGER;
                for (const [uri, timestamp] of Object.entries(data)) {
                    if (min > timestamp) {
                        min = data[uri];
                        toDelete = [uri, timestamp];
                    }
                }
            }
            if (toDelete) {
                const [toDeleteUri] = toDelete;
                delete data[toDeleteUri];
                this.logger.debug(`Deleted sketch entry ${JSON.stringify(toDelete)} from recently opened.`);
            }
            await this.saveRecentSketches(data);
            this.logger.debug(`Marked sketch '${uri}' as recently opened.`);
            const sketches = await this.recentlyOpenedSketches(data);
            this.notificationService.notifyRecentSketchesDidChange({ sketches });
        });
    }
    async recentlyOpenedSketches(forceUpdate) {
        if (!this.recentSketches || forceUpdate) {
            const data = forceUpdate && typeof forceUpdate === 'object'
                ? forceUpdate
                : await this.loadRecentSketches();
            const sketches = [];
            let needsUpdate = false;
            for (const uri of Object.keys(data).sort((left, right) => data[right] - data[left])) {
                let sketch = undefined;
                try {
                    sketch = await this.loadSketch(uri);
                }
                catch (_a) { }
                if (!sketch) {
                    needsUpdate = true;
                }
                else {
                    sketches.push(sketch);
                }
            }
            if (needsUpdate) {
                const data = sketches.reduce((acc, curr) => {
                    acc[curr.uri] = curr.mtimeMs;
                    return acc;
                }, {});
                await this.saveRecentSketches(data);
                this.notificationService.notifyRecentSketchesDidChange({ sketches });
            }
            this.recentSketches = sketches;
        }
        return this.recentSketches;
    }
    async cloneExample(uri) {
        const [sketch, parentPath] = await Promise.all([
            this.loadSketch(uri),
            this.createTempFolder(),
        ]);
        const destinationUri = file_uri_1.FileUri.create(path.join(parentPath, sketch.name)).toString();
        const copiedSketchUri = await this.copy(sketch, { destinationUri });
        return this.loadSketch(copiedSketchUri);
    }
    async createNewSketch() {
        const monthNames = [
            'jan',
            'feb',
            'mar',
            'apr',
            'may',
            'jun',
            'jul',
            'aug',
            'sep',
            'oct',
            'nov',
            'dec',
        ];
        const today = new Date();
        const parentPath = await this.createTempFolder();
        const sketchBaseName = `sketch_${monthNames[today.getMonth()]}${today.getDate()}`;
        const config = await this.configService.getConfiguration();
        const sketchbookPath = file_uri_1.FileUri.fsPath(config.sketchDirUri);
        let sketchName;
        // If it's another day, reset the count of sketches created today
        if (this.lastSketchBaseName !== sketchBaseName)
            this.sketchSuffixIndex = 1;
        let nameFound = false;
        while (!nameFound) {
            const sketchNameCandidate = `${sketchBaseName}${sketchIndexToLetters(this.sketchSuffixIndex++)}`;
            // Note: we check the future destination folder (`directories.user`) for name collision and not the temp folder!
            const sketchExists = await this.exists(path.join(sketchbookPath, sketchNameCandidate));
            if (!sketchExists) {
                nameFound = true;
                sketchName = sketchNameCandidate;
            }
        }
        if (!sketchName) {
            throw new Error('Cannot create a unique sketch name');
        }
        this.lastSketchBaseName = sketchBaseName;
        const sketchDir = path.join(parentPath, sketchName);
        const sketchFile = path.join(sketchDir, `${sketchName}.ino`);
        const [inoContent] = await Promise.all([
            this.loadInoContent(),
            fs_1.promises.mkdir(sketchDir, { recursive: true }),
        ]);
        await fs_1.promises.writeFile(sketchFile, inoContent, { encoding: 'utf8' });
        return this.loadSketch(file_uri_1.FileUri.create(sketchDir).toString());
    }
    /**
     * Creates a temp folder and returns with a promise that resolves with the canonicalized absolute pathname of the newly created temp folder.
     * This method ensures that the file-system path pointing to the new temp directory is fully resolved.
     * For example, on Windows, instead of getting an [8.3 filename](https://en.wikipedia.org/wiki/8.3_filename), callers will get a fully resolved path.
     * `C:\\Users\\KITTAA~1\\AppData\\Local\\Temp\\.arduinoIDE-unsaved2022615-21100-iahybb.yyvh\\sketch_jul15a` will be `C:\\Users\\kittaakos\\AppData\\Local\\Temp\\.arduinoIDE-unsaved2022615-21100-iahybb.yyvh\\sketch_jul15a`
     */
    createTempFolder() {
        return new Promise((resolve, reject) => {
            temp.mkdir({ prefix: is_temp_sketch_1.TempSketchPrefix }, (createError, dirPath) => {
                if (createError) {
                    reject(createError);
                    return;
                }
                fs_1.realpath.native(dirPath, (resolveError, resolvedDirPath) => {
                    if (resolveError) {
                        reject(resolveError);
                        return;
                    }
                    resolve(resolvedDirPath);
                });
            });
        });
    }
    async getSketchFolder(uri) {
        if (!uri) {
            return undefined;
        }
        let currentUri = new uri_1.default(uri);
        while (currentUri && !currentUri.path.isRoot) {
            const sketch = await this._isSketchFolder(currentUri.toString());
            if (sketch) {
                return sketch;
            }
            currentUri = currentUri.parent;
        }
        return undefined;
    }
    async isSketchFolder(uri) {
        const sketch = await this._isSketchFolder(uri);
        return !!sketch;
    }
    async _isSketchFolder(uri) {
        try {
            const sketch = await this.loadSketch(uri);
            return sketch;
        }
        catch (err) {
            if (sketches_service_1.SketchesError.NotFound.is(err) || sketches_service_1.SketchesError.InvalidName.is(err)) {
                return undefined;
            }
            throw err;
        }
    }
    async isTemp(sketch) {
        return this.isTempSketch.is(file_uri_1.FileUri.fsPath(sketch.uri));
    }
    async copy(sketch, { destinationUri }) {
        const source = file_uri_1.FileUri.fsPath(sketch.uri);
        const exists = await this.exists(source);
        if (!exists) {
            throw new Error(`Sketch does not exist: ${sketch}`);
        }
        // Nothing to do when source and destination are the same.
        if (sketch.uri === destinationUri) {
            await this.loadSketch(sketch.uri); // Sanity check.
            return sketch.uri;
        }
        const copy = async (sourcePath, destinationPath) => {
            return new Promise((resolve, reject) => {
                ncp_1.ncp.ncp(sourcePath, destinationPath, async (error) => {
                    if (error) {
                        reject(error);
                        return;
                    }
                    const newName = path.basename(destinationPath);
                    try {
                        const oldPath = path.join(destinationPath, new uri_1.default(sketch.mainFileUri).path.base);
                        const newPath = path.join(destinationPath, `${newName}.ino`);
                        if (oldPath !== newPath) {
                            await fs_1.promises.rename(oldPath, newPath);
                        }
                        await this.loadSketch(file_uri_1.FileUri.create(destinationPath).toString()); // Sanity check.
                        resolve();
                    }
                    catch (e) {
                        reject(e);
                    }
                });
            });
        };
        // https://github.com/arduino/arduino-ide/issues/65
        // When copying `/path/to/sketchbook/sketch_A` to `/path/to/sketchbook/sketch_A/anything` on a non-POSIX filesystem,
        // `ncp` makes a recursion and copies the folders over and over again. In such cases, we copy the source into a temp folder,
        // then move it to the desired destination.
        const destination = file_uri_1.FileUri.fsPath(destinationUri);
        let tempDestination = await this.createTempFolder();
        tempDestination = path.join(tempDestination, sketch.name);
        await fs_1.promises.mkdir(tempDestination, { recursive: true });
        await copy(source, tempDestination);
        await copy(tempDestination, destination);
        return file_uri_1.FileUri.create(destination).toString();
    }
    async archive(sketch, destinationUri) {
        await this.loadSketch(sketch.uri); // sanity check
        const { client } = await this.coreClient;
        const archivePath = file_uri_1.FileUri.fsPath(destinationUri);
        // The CLI cannot override existing archives, so we have to wipe it manually: https://github.com/arduino/arduino-cli/issues/1160
        if (await this.exists(archivePath)) {
            await fs_1.promises.unlink(archivePath);
        }
        const req = new commands_pb_1.ArchiveSketchRequest();
        req.setSketchPath(file_uri_1.FileUri.fsPath(sketch.uri));
        req.setArchivePath(archivePath);
        await new Promise((resolve, reject) => {
            client.archiveSketch(req, (err) => {
                if (err) {
                    reject(err);
                    return;
                }
                resolve(destinationUri);
            });
        });
        return destinationUri;
    }
    async getIdeTempFolderUri(sketch) {
        const genBuildPath = await this.getIdeTempFolderPath(sketch);
        return file_uri_1.FileUri.create(genBuildPath).toString();
    }
    async getIdeTempFolderPath(sketch) {
        const sketchPath = file_uri_1.FileUri.fsPath(sketch.uri);
        await fs_1.promises.readdir(sketchPath); // Validates the sketch folder and rejects if not accessible.
        const suffix = crypto.createHash('md5').update(sketchPath).digest('hex');
        return path.join(os.tmpdir(), `arduino-ide2-${suffix}`);
    }
    async deleteSketch(sketch) {
        return new Promise((resolve, reject) => {
            const sketchPath = file_uri_1.FileUri.fsPath(sketch.uri);
            (0, fs_1.rm)(sketchPath, { recursive: true, maxRetries: 5 }, (error) => {
                if (error) {
                    this.logger.error(`Failed to delete sketch at ${sketchPath}.`, error);
                    reject(error);
                }
                else {
                    this.logger.info(`Successfully deleted sketch at ${sketchPath}.`);
                    resolve();
                }
            });
        });
    }
    async exists(pathLike) {
        try {
            await fs_1.promises.access(pathLike, fs_1.constants.R_OK | fs_1.constants.W_OK);
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    // Returns the default.ino from the settings or from default folder.
    async readSettings() {
        const configDirUri = await this.envVariableServer.getConfigDirUri();
        const configDirPath = file_uri_1.FileUri.fsPath(configDirUri);
        try {
            const raw = await fs_1.promises.readFile((0, path_1.join)(configDirPath, 'settings.json'), {
                encoding: 'utf8',
            });
            return this.tryParse(raw);
        }
        catch (err) {
            if ('code' in err && err.code === 'ENOENT') {
                return undefined;
            }
            throw err;
        }
    }
    tryParse(raw) {
        try {
            return JSON.parse(raw);
        }
        catch (_a) {
            return undefined;
        }
    }
    // Returns the default.ino from the settings or from default folder.
    async loadInoContent() {
        if (!this.inoContent) {
            this.inoContent = new promise_util_1.Deferred();
            const settings = await this.readSettings();
            if (settings) {
                const inoBlueprintPath = settings['arduino.sketch.inoBlueprint'];
                if (inoBlueprintPath && typeof inoBlueprintPath === 'string') {
                    try {
                        const inoContent = await fs_1.promises.readFile(inoBlueprintPath, {
                            encoding: 'utf8',
                        });
                        this.inoContent.resolve(inoContent);
                    }
                    catch (err) {
                        if ('code' in err && err.code === 'ENOENT') {
                            // Ignored. The custom `.ino` blueprint file is optional.
                        }
                        else {
                            throw err;
                        }
                    }
                }
            }
            this.inoContent.resolve(DefaultIno);
        }
        return this.inoContent.promise;
    }
};
__decorate([
    (0, inversify_1.inject)(logger_1.ILogger),
    (0, inversify_1.named)('sketches-service'),
    __metadata("design:type", Object)
], SketchesServiceImpl.prototype, "logger", void 0);
__decorate([
    (0, inversify_1.inject)(config_service_impl_1.ConfigServiceImpl),
    __metadata("design:type", config_service_impl_1.ConfigServiceImpl)
], SketchesServiceImpl.prototype, "configService", void 0);
__decorate([
    (0, inversify_1.inject)(notification_service_server_1.NotificationServiceServerImpl),
    __metadata("design:type", notification_service_server_1.NotificationServiceServerImpl)
], SketchesServiceImpl.prototype, "notificationService", void 0);
__decorate([
    (0, inversify_1.inject)(env_variables_1.EnvVariablesServer),
    __metadata("design:type", Object)
], SketchesServiceImpl.prototype, "envVariableServer", void 0);
__decorate([
    (0, inversify_1.inject)(is_temp_sketch_1.IsTempSketch),
    __metadata("design:type", is_temp_sketch_1.IsTempSketch)
], SketchesServiceImpl.prototype, "isTempSketch", void 0);
SketchesServiceImpl = __decorate([
    (0, inversify_1.injectable)()
], SketchesServiceImpl);
exports.SketchesServiceImpl = SketchesServiceImpl;
function isNotFoundError(err) {
    return service_error_1.ServiceError.is(err) && err.code === 5; // `NOT_FOUND` https://grpc.github.io/grpc/core/md_doc_statuscodes.html
}
/**
 * Tries to detect whether the error was caused by an invalid main sketch file name.
 * IDE2 should handle gracefully when there is an invalid sketch folder name. See the [spec](https://arduino.github.io/arduino-cli/latest/sketch-specification/#sketch-root-folder) for details.
 * The CLI does not have error codes (https://github.com/arduino/arduino-cli/issues/1762), so IDE2 parses the error message and tries to guess it.
 * Nothing guarantees that the invalid existing main sketch file still exits by the time client performs the sketch move.
 */
async function isInvalidSketchNameError(cliErr, requestSketchPath) {
    if (isNotFoundError(cliErr)) {
        const ino = requestSketchPath.endsWith('.ino');
        if (ino) {
            const sketchFolderPath = path.dirname(requestSketchPath);
            const sketchName = path.basename(sketchFolderPath);
            const pattern = `${invalidSketchNameErrorRegExpPrefix}${path.join(sketchFolderPath, `${sketchName}.ino`)}`.replace(/\\/g, '\\\\'); // make windows path separator with \\ to have a valid regexp.
            if (new RegExp(pattern, 'i').test(cliErr.details)) {
                try {
                    await fs_1.promises.access(requestSketchPath);
                    return requestSketchPath;
                }
                catch (_a) {
                    return undefined;
                }
            }
        }
        else {
            try {
                const resources = await fs_1.promises.readdir(requestSketchPath, {
                    withFileTypes: true,
                });
                return (resources
                    .filter((resource) => resource.isFile())
                    .filter((resource) => resource.name.endsWith('.ino'))
                    // A folder might contain multiple sketches. It's OK to ick the first one as IDE2 cannot do much,
                    // but ensure a deterministic behavior as `readdir(3)` does not guarantee an order. Sort them.
                    .sort(({ name: left }, { name: right }) => left.localeCompare(right))
                    .map(({ name }) => name)
                    .map((name) => path.join(requestSketchPath, name))[0]);
            }
            catch (err) {
                if ('code' in err && err.code === 'ENOTDIR') {
                    return undefined;
                }
                throw err;
            }
        }
    }
    return undefined;
}
const invalidSketchNameErrorRegExpPrefix = '.*: main file missing from sketch: ';
/*
 * When a new sketch is created, add a suffix to distinguish it
 * from other new sketches I created today.
 * If 'sketch_jul8a' is already used, go with 'sketch_jul8b'.
 * If 'sketch_jul8b' already used, go with 'sketch_jul8c'.
 * When it reach 'sketch_jul8z', go with 'sketch_jul8aa',
 * and so on.
 */
function sketchIndexToLetters(num) {
    let out = '';
    let pow;
    do {
        pow = Math.floor(num / 26);
        const mod = num % 26;
        out = (mod ? String.fromCharCode(96 + mod) : (--pow, 'z')) + out;
        num = pow;
    } while (pow > 0);
    return out;
}
//# sourceMappingURL=sketches-service-impl.js.map