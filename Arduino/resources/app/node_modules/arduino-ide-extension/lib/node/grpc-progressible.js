"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DownloadResult = exports.IndexesUpdateProgressHandler = exports.ExecuteWithProgress = void 0;
const uuid_1 = require("uuid");
const commands_pb_1 = require("./cli-protocol/cc/arduino/cli/commands/v1/commands_pb");
const common_pb_1 = require("./cli-protocol/cc/arduino/cli/commands/v1/common_pb");
const compile_pb_1 = require("./cli-protocol/cc/arduino/cli/commands/v1/compile_pb");
const core_pb_1 = require("./cli-protocol/cc/arduino/cli/commands/v1/core_pb");
const lib_pb_1 = require("./cli-protocol/cc/arduino/cli/commands/v1/lib_pb");
const upload_pb_1 = require("./cli-protocol/cc/arduino/cli/commands/v1/upload_pb");
var LibraryProgressResponse;
(function (LibraryProgressResponse) {
    function is(response) {
        return (response instanceof lib_pb_1.LibraryInstallResponse ||
            response instanceof lib_pb_1.LibraryUninstallResponse ||
            response instanceof lib_pb_1.ZipLibraryInstallResponse);
    }
    LibraryProgressResponse.is = is;
    function workUnit(response) {
        return Object.assign({ task: response.getTaskProgress() }, (response instanceof lib_pb_1.LibraryInstallResponse && {
            download: response.getProgress(),
        }));
    }
    LibraryProgressResponse.workUnit = workUnit;
})(LibraryProgressResponse || (LibraryProgressResponse = {}));
var PlatformProgressResponse;
(function (PlatformProgressResponse) {
    function is(response) {
        return (response instanceof core_pb_1.PlatformInstallResponse ||
            response instanceof core_pb_1.PlatformUninstallResponse);
    }
    PlatformProgressResponse.is = is;
    function workUnit(response) {
        return Object.assign({ task: response.getTaskProgress() }, (response instanceof core_pb_1.PlatformInstallResponse && {
            download: response.getProgress(),
        }));
    }
    PlatformProgressResponse.workUnit = workUnit;
})(PlatformProgressResponse || (PlatformProgressResponse = {}));
var IndexProgressResponse;
(function (IndexProgressResponse) {
    function is(response) {
        return (response instanceof commands_pb_1.UpdateIndexResponse ||
            response instanceof commands_pb_1.UpdateLibrariesIndexResponse ||
            response instanceof commands_pb_1.UpdateCoreLibrariesIndexResponse // not used by the IDE2 but available for full typings compatibility
        );
    }
    IndexProgressResponse.is = is;
    function workUnit(response) {
        return {
            download: response.getDownloadProgress(),
        };
    }
    IndexProgressResponse.workUnit = workUnit;
})(IndexProgressResponse || (IndexProgressResponse = {}));
var IndefiniteProgressResponse;
(function (IndefiniteProgressResponse) {
    function is(response) {
        return (response instanceof upload_pb_1.UploadResponse ||
            response instanceof upload_pb_1.UploadUsingProgrammerResponse ||
            response instanceof upload_pb_1.BurnBootloaderResponse);
    }
    IndefiniteProgressResponse.is = is;
})(IndefiniteProgressResponse || (IndefiniteProgressResponse = {}));
var DefiniteProgressResponse;
(function (DefiniteProgressResponse) {
    function is(response) {
        return response instanceof compile_pb_1.CompileResponse;
    }
    DefiniteProgressResponse.is = is;
})(DefiniteProgressResponse || (DefiniteProgressResponse = {}));
var CoreProgressResponse;
(function (CoreProgressResponse) {
    function is(response) {
        return (DefiniteProgressResponse.is(response) ||
            IndefiniteProgressResponse.is(response));
    }
    CoreProgressResponse.is = is;
    function workUnit(response) {
        if (DefiniteProgressResponse.is(response)) {
            return { task: response.getProgress() };
        }
        return UnitOfWork.Unknown;
    }
    CoreProgressResponse.workUnit = workUnit;
})(CoreProgressResponse || (CoreProgressResponse = {}));
var UnitOfWork;
(function (UnitOfWork) {
    UnitOfWork.Unknown = {};
})(UnitOfWork || (UnitOfWork = {}));
/**
 * It's solely a dev thing. Flip it to `true` if you want to debug the progress from the CLI responses.
 */
const DEBUG = false;
var ExecuteWithProgress;
(function (ExecuteWithProgress) {
    function createDataCallback({ responseService, progressId, reportResult, }) {
        const uuid = (0, uuid_1.v4)();
        let message = '';
        let url = '';
        return (response) => {
            var _a, _b, _c, _d, _e, _f;
            if (DEBUG) {
                const json = toJson(response);
                if (json) {
                    console.debug(`[gRPC progress] Progress response [${uuid}]: ${json}`);
                }
            }
            const unitOfWork = resolve(response);
            const { task, download } = unitOfWork;
            if (!download && !task) {
                // Report a fake unknown progress if progress ID is available.
                // When a progress ID is available, a connected client is setting the progress ID.
                // Hence, it's listening to progress updates.
                if (unitOfWork === UnitOfWork.Unknown && progressId) {
                    if (progressId) {
                        (_a = responseService.reportProgress) === null || _a === void 0 ? void 0 : _a.call(responseService, {
                            progressId,
                            message: '',
                            work: { done: Number.NaN, total: Number.NaN },
                        });
                    }
                    return;
                }
                if (DEBUG) {
                    // This is still an API error from the CLI, but IDE2 ignores it.
                    // Technically, it does not cause an error, but could mess up the progress reporting.
                    // See an example of an empty object `{}` repose here: https://github.com/arduino/arduino-ide/issues/906#issuecomment-1171145630.
                    console.warn(`Implementation error. None of the following properties were available on the response: 'task', 'download'`);
                }
                return;
            }
            if (task && download) {
                throw new Error("Implementation error. Both 'download' and 'task' are available.");
            }
            if (task) {
                const message = task.getName() || task.getMessage();
                const percent = task.getPercent();
                if (message) {
                    if (progressId) {
                        (_b = responseService.reportProgress) === null || _b === void 0 ? void 0 : _b.call(responseService, {
                            progressId,
                            message,
                            work: { done: Number.NaN, total: Number.NaN },
                        });
                    }
                    (_c = responseService.appendToOutput) === null || _c === void 0 ? void 0 : _c.call(responseService, { chunk: `${message}\n` });
                }
                else if (percent) {
                    if (progressId) {
                        (_d = responseService.reportProgress) === null || _d === void 0 ? void 0 : _d.call(responseService, {
                            progressId,
                            message,
                            work: { done: percent, total: 100 },
                        });
                    }
                }
            }
            else if (download) {
                const phase = phaseOf(download);
                if (phase instanceof common_pb_1.DownloadProgressStart) {
                    message = phase.getLabel();
                    url = phase.getUrl();
                    (_e = responseService.appendToOutput) === null || _e === void 0 ? void 0 : _e.call(responseService, { chunk: `${message}\n` });
                }
                else if (phase instanceof common_pb_1.DownloadProgressUpdate) {
                    if (progressId && message) {
                        (_f = responseService.reportProgress) === null || _f === void 0 ? void 0 : _f.call(responseService, {
                            progressId,
                            message,
                            work: {
                                total: phase.getTotalSize(),
                                done: phase.getDownloaded(),
                            },
                        });
                    }
                }
                else if (phase instanceof common_pb_1.DownloadProgressEnd) {
                    if (url && reportResult) {
                        reportResult({
                            url,
                            message: phase.getMessage(),
                            success: phase.getSuccess(),
                        });
                    }
                    message = '';
                    url = '';
                }
            }
        };
    }
    ExecuteWithProgress.createDataCallback = createDataCallback;
    function resolve(response) {
        if (LibraryProgressResponse.is(response)) {
            return LibraryProgressResponse.workUnit(response);
        }
        else if (PlatformProgressResponse.is(response)) {
            return PlatformProgressResponse.workUnit(response);
        }
        else if (IndexProgressResponse.is(response)) {
            return IndexProgressResponse.workUnit(response);
        }
        else if (CoreProgressResponse.is(response)) {
            return CoreProgressResponse.workUnit(response);
        }
        console.warn('Unhandled gRPC response', response);
        return {};
    }
    function toJson(response) {
        return JSON.stringify(response.toObject(false));
    }
    function phaseOf(download) {
        let start = undefined;
        let update = undefined;
        let end = undefined;
        if (download.hasStart()) {
            start = download.getStart();
        }
        else if (download.hasUpdate()) {
            update = download.getUpdate();
        }
        else if (download.hasEnd()) {
            end = download.getEnd();
        }
        else {
            throw new Error(`Download progress does not have a 'start', 'update', and 'end'. ${JSON.stringify(download.toObject(false))}`);
        }
        if (start) {
            return start;
        }
        else if (update) {
            return update;
        }
        else if (end) {
            return end;
        }
        else {
            throw new Error(`Download progress does not have a 'start', 'update', and 'end'. ${JSON.stringify(download.toObject(false))}`);
        }
    }
})(ExecuteWithProgress = exports.ExecuteWithProgress || (exports.ExecuteWithProgress = {}));
class IndexesUpdateProgressHandler {
    constructor(types, additionalUrlsCount, options) {
        var _a, _b;
        this.types = types;
        this.options = options;
        this.done = 0;
        this.progressId = (0, uuid_1.v4)();
        this.results = [];
        this.total = IndexesUpdateProgressHandler.total(types, additionalUrlsCount);
        // Note: at this point, the IDE2 backend might not have any connected clients, so this notification is not delivered to anywhere
        // Hence, clients must handle gracefully when no `willStart` event is received before any `didProgress`.
        (_b = (_a = this.options).onStart) === null || _b === void 0 ? void 0 : _b.call(_a, { progressId: this.progressId, types });
    }
    reportEnd() {
        var _a, _b;
        const updatedAt = new Date().toISOString();
        (_b = (_a = this.options).onComplete) === null || _b === void 0 ? void 0 : _b.call(_a, {
            progressId: this.progressId,
            summary: this.types.reduce((summary, type) => {
                summary[type] = updatedAt;
                return summary;
            }, {}),
        });
    }
    reportProgress(message) {
        this.options.onProgress({
            message,
            progressId: this.progressId,
            work: { total: this.total, done: ++this.done },
        });
    }
    reportError(message) {
        var _a, _b;
        (_b = (_a = this.options).onError) === null || _b === void 0 ? void 0 : _b.call(_a, {
            progressId: this.progressId,
            message,
            types: this.types,
        });
    }
    reportResult(result) {
        this.results.push(result);
    }
    static total(types, additionalUrlsCount) {
        let total = 0;
        if (types.includes('library')) {
            // The `library_index.json.gz` and `library_index.json.sig` when running the library index update.
            total += 2;
        }
        if (types.includes('platform')) {
            // +1 for the `package_index.tar.bz2` when updating the platform index.
            total += additionalUrlsCount + 1;
        }
        // +1 for the `initInstance` call after the index update (`reportEnd`)
        return total + 1;
    }
}
exports.IndexesUpdateProgressHandler = IndexesUpdateProgressHandler;
var DownloadResult;
(function (DownloadResult) {
    function isError(arg) {
        return !!arg.message && !arg.success;
    }
    DownloadResult.isError = isError;
})(DownloadResult = exports.DownloadResult || (exports.DownloadResult = {}));
//# sourceMappingURL=grpc-progressible.js.map