"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SerialMonitorSendInput = void 0;
const React = require("@theia/core/shared/react");
const keys_1 = require("@theia/core/lib/browser/keys");
const boards_service_1 = require("../../../common/protocol/boards-service");
const common_1 = require("@theia/core/lib/common");
const nls_1 = require("../../../common/nls");
class HistoryList {
    constructor(size = 100) {
        this.size = size;
        this.items = [];
        this.index = -1;
    }
    push(val) {
        if (val !== this.items[this.items.length - 1]) {
            this.items.push(val);
        }
        while (this.items.length > this.size) {
            this.items.shift();
        }
        this.index = -1;
    }
    previous() {
        if (this.index === -1) {
            this.index = this.items.length - 1;
            return this.items[this.index];
        }
        if (this.hasPrevious) {
            return this.items[--this.index];
        }
        return this.items[this.index];
    }
    get hasPrevious() {
        return this.index >= 1;
    }
    next() {
        if (this.index === this.items.length - 1) {
            this.index = -1;
            return '';
        }
        if (this.hasNext) {
            return this.items[++this.index];
        }
        return '';
    }
    get hasNext() {
        return this.index >= 0 && this.index !== this.items.length - 1;
    }
}
class SerialMonitorSendInput extends React.Component {
    constructor(props) {
        super(props);
        this.toDisposeBeforeUnmount = new common_1.DisposableCollection();
        this.setRef = (element) => {
            if (this.props.resolveFocus) {
                this.props.resolveFocus(element || undefined);
            }
        };
        this.state = { text: '', connected: true, history: new HistoryList() };
        this.onChange = this.onChange.bind(this);
        this.onSend = this.onSend.bind(this);
        this.onKeyDown = this.onKeyDown.bind(this);
    }
    componentDidMount() {
        this.setState({ connected: this.props.monitorModel.connected });
        this.toDisposeBeforeUnmount.push(this.props.monitorModel.onChange(({ property }) => {
            if (property === 'connected')
                this.setState({ connected: this.props.monitorModel.connected });
        }));
    }
    componentWillUnmount() {
        // TODO: "Your preferred browser's local storage is almost full." Discard `content` before saving layout?
        this.toDisposeBeforeUnmount.dispose();
    }
    render() {
        return (React.createElement("input", { ref: this.setRef, type: "text", className: `theia-input ${this.shouldShowWarning() ? 'warning' : ''}`, placeholder: this.placeholder, value: this.state.text, onChange: this.onChange, onKeyDown: this.onKeyDown }));
    }
    shouldShowWarning() {
        const board = this.props.boardsServiceProvider.boardsConfig.selectedBoard;
        const port = this.props.boardsServiceProvider.boardsConfig.selectedPort;
        return !this.state.connected || !board || !port;
    }
    get placeholder() {
        if (this.shouldShowWarning()) {
            return common_1.nls.localize('arduino/serial/notConnected', 'Not connected. Select a board and a port to connect automatically.');
        }
        const board = this.props.boardsServiceProvider.boardsConfig.selectedBoard;
        const port = this.props.boardsServiceProvider.boardsConfig.selectedPort;
        return common_1.nls.localize('arduino/serial/message', "Message (Enter to send message to '{0}' on '{1}')", board
            ? boards_service_1.Board.toString(board, {
                useFqbn: false,
            })
            : nls_1.Unknown, port ? port.address : nls_1.Unknown);
    }
    onChange(event) {
        this.setState({ text: event.target.value });
    }
    onSend() {
        this.props.onSend(this.state.text + this.props.monitorModel.lineEnding);
        this.setState({ text: '' });
    }
    onKeyDown(event) {
        const keyCode = keys_1.KeyCode.createKeyCode(event.nativeEvent);
        if (keyCode) {
            const { key } = keyCode;
            if (key === keys_1.Key.ENTER) {
                const { text } = this.state;
                this.onSend();
                if (text) {
                    this.state.history.push(text);
                }
            }
            else if (key === keys_1.Key.ARROW_UP) {
                this.setState({ text: this.state.history.previous() });
            }
            else if (key === keys_1.Key.ARROW_DOWN) {
                this.setState({ text: this.state.history.next() });
            }
            else if (key === keys_1.Key.ESCAPE) {
                this.setState({ text: '' });
            }
        }
    }
}
exports.SerialMonitorSendInput = SerialMonitorSendInput;
//# sourceMappingURL=serial-monitor-send-input.js.map