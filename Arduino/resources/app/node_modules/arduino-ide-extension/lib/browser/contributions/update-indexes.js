"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var UpdateIndexes_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateIndexes = void 0;
const storage_service_1 = require("@theia/core/lib/browser/storage-service");
const nls_1 = require("@theia/core/lib/common/nls");
const inversify_1 = require("@theia/core/shared/inversify");
const protocol_1 = require("../../common/protocol");
const notification_center_1 = require("../notification-center");
const window_service_ext_1 = require("../theia/core/window-service-ext");
const contribution_1 = require("./contribution");
let UpdateIndexes = UpdateIndexes_1 = class UpdateIndexes extends contribution_1.Contribution {
    init() {
        super.init();
        this.notificationCenter.onIndexUpdateDidComplete(({ summary }) => Promise.all(Object.entries(summary).map(([type, updatedAt]) => this.setLastUpdateDateTime(type, updatedAt))));
    }
    onReady() {
        this.checkForUpdates();
    }
    registerCommands(registry) {
        registry.registerCommand(UpdateIndexes_1.Commands.UPDATE_INDEXES, {
            execute: () => this.updateIndexes(protocol_1.IndexType.All, true),
        });
        registry.registerCommand(UpdateIndexes_1.Commands.UPDATE_PLATFORM_INDEX, {
            execute: () => this.updateIndexes(['platform'], true),
        });
        registry.registerCommand(UpdateIndexes_1.Commands.UPDATE_LIBRARY_INDEX, {
            execute: () => this.updateIndexes(['library'], true),
        });
    }
    async checkForUpdates() {
        const checkForUpdates = this.preferences['arduino.checkForUpdates'];
        if (!checkForUpdates) {
            console.debug('[update-indexes]: `arduino.checkForUpdates` is `false`. Skipping updating the indexes.');
            return;
        }
        if (await this.windowService.isFirstWindow()) {
            const summary = await this.coreService.indexUpdateSummaryBeforeInit();
            if (summary.message) {
                this.messageService.error(summary.message);
            }
            const typesToCheck = protocol_1.IndexType.All.filter((type) => !(type in summary));
            if (Object.keys(summary).length) {
                console.debug(`[update-indexes]: Detected an index update summary before the core gRPC client initialization. Updating local storage with ${JSON.stringify(summary)}`);
            }
            else {
                console.debug('[update-indexes]: No index update summary was available before the core gRPC client initialization. Checking the status of the all the index types.');
            }
            await Promise.allSettled([
                ...Object.entries(summary).map(([type, updatedAt]) => this.setLastUpdateDateTime(type, updatedAt)),
                this.updateIndexes(typesToCheck),
            ]);
        }
    }
    async updateIndexes(types, force = false) {
        const updatedAt = new Date().toISOString();
        return Promise.all(types.map((type) => this.needsIndexUpdate(type, updatedAt, force))).then((needsIndexUpdateResults) => {
            const typesToUpdate = needsIndexUpdateResults.filter(protocol_1.IndexType.is);
            if (typesToUpdate.length) {
                console.debug(`[update-indexes]: Requesting the index update of type: ${JSON.stringify(typesToUpdate)} with date time: ${updatedAt}.`);
                return this.coreService.updateIndex({ types: typesToUpdate });
            }
        });
    }
    async needsIndexUpdate(type, now, force = false) {
        if (force) {
            console.debug(`[update-indexes]: Update for index type: '${type}' was forcefully requested.`);
            return type;
        }
        const lastUpdateIsoDateTime = await this.getLastUpdateDateTime(type);
        if (!lastUpdateIsoDateTime) {
            console.debug(`[update-indexes]: No last update date time was persisted for index type: '${type}'. Index update is required.`);
            return type;
        }
        const lastUpdateDateTime = Date.parse(lastUpdateIsoDateTime);
        if (Number.isNaN(lastUpdateDateTime)) {
            console.debug(`[update-indexes]: Invalid last update date time was persisted for index type: '${type}'. Last update date time was: ${lastUpdateDateTime}. Index update is required.`);
            return type;
        }
        const diff = new Date(now).getTime() - lastUpdateDateTime;
        const needsIndexUpdate = diff >= this.threshold;
        console.debug(`[update-indexes]: Update for index type '${type}' is ${needsIndexUpdate ? '' : 'not '}required. Now: ${now}, Last index update date time: ${new Date(lastUpdateDateTime).toISOString()}, diff: ${diff} ms, threshold: ${this.threshold} ms.`);
        return needsIndexUpdate ? type : false;
    }
    async getLastUpdateDateTime(type) {
        const key = this.storageKeyOf(type);
        return this.localStorage.getData(key);
    }
    async setLastUpdateDateTime(type, updatedAt) {
        const key = this.storageKeyOf(type);
        return this.localStorage.setData(key, updatedAt).finally(() => {
            console.debug(`[update-indexes]: Updated the last index update date time of '${type}' to ${updatedAt}.`);
        });
    }
    storageKeyOf(type) {
        return `index-last-update-time--${type}`;
    }
    get threshold() {
        return 4 * 60 * 60 * 1000; // four hours in millis
    }
};
__decorate([
    (0, inversify_1.inject)(window_service_ext_1.WindowServiceExt),
    __metadata("design:type", Object)
], UpdateIndexes.prototype, "windowService", void 0);
__decorate([
    (0, inversify_1.inject)(storage_service_1.LocalStorageService),
    __metadata("design:type", storage_service_1.LocalStorageService)
], UpdateIndexes.prototype, "localStorage", void 0);
__decorate([
    (0, inversify_1.inject)(protocol_1.CoreService),
    __metadata("design:type", Object)
], UpdateIndexes.prototype, "coreService", void 0);
__decorate([
    (0, inversify_1.inject)(notification_center_1.NotificationCenter),
    __metadata("design:type", notification_center_1.NotificationCenter)
], UpdateIndexes.prototype, "notificationCenter", void 0);
UpdateIndexes = UpdateIndexes_1 = __decorate([
    (0, inversify_1.injectable)()
], UpdateIndexes);
exports.UpdateIndexes = UpdateIndexes;
(function (UpdateIndexes) {
    let Commands;
    (function (Commands) {
        Commands.UPDATE_INDEXES = {
            id: 'arduino-update-indexes',
            label: nls_1.nls.localize('arduino/updateIndexes/updateIndexes', 'Update Indexes'),
            category: 'Arduino',
        };
        Commands.UPDATE_PLATFORM_INDEX = {
            id: 'arduino-update-package-index',
            label: nls_1.nls.localize('arduino/updateIndexes/updatePackageIndex', 'Update Package Index'),
            category: 'Arduino',
        };
        Commands.UPDATE_LIBRARY_INDEX = {
            id: 'arduino-update-library-index',
            label: nls_1.nls.localize('arduino/updateIndexes/updateLibraryIndex', 'Update Library Index'),
            category: 'Arduino',
        };
    })(Commands = UpdateIndexes.Commands || (UpdateIndexes.Commands = {}));
})(UpdateIndexes = exports.UpdateIndexes || (exports.UpdateIndexes = {}));
exports.UpdateIndexes = UpdateIndexes;
//# sourceMappingURL=update-indexes.js.map