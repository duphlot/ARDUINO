"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var OpenSketchFiles_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.OpenSketchFiles = void 0;
const nls_1 = require("@theia/core/lib/common/nls");
const inversify_1 = require("@theia/core/shared/inversify");
const nls_2 = require("../../common/nls");
const protocol_1 = require("../../common/protocol");
const contribution_1 = require("./contribution");
const save_as_sketch_1 = require("./save-as-sketch");
const open_sketch_1 = require("./open-sketch");
const promise_util_1 = require("@theia/core/lib/common/promise-util");
const disposable_1 = require("@theia/core/lib/common/disposable");
const contextKeyService_1 = require("@theia/monaco-editor-core/esm/vs/platform/contextkey/browser/contextKeyService");
let OpenSketchFiles = OpenSketchFiles_1 = class OpenSketchFiles extends contribution_1.SketchContribution {
    registerCommands(registry) {
        registry.registerCommand(OpenSketchFiles_1.Commands.OPEN_SKETCH_FILES, {
            execute: (uri) => this.openSketchFiles(uri),
        });
        registry.registerCommand(OpenSketchFiles_1.Commands.ENSURE_OPENED, {
            execute: (uri, forceOpen, options) => {
                this.ensureOpened(uri, forceOpen, options);
            },
        });
    }
    async openSketchFiles(uri) {
        try {
            const sketch = await this.sketchService.loadSketch(uri.toString());
            const { mainFileUri, rootFolderFileUris } = sketch;
            for (const uri of [mainFileUri, ...rootFolderFileUris]) {
                await this.ensureOpened(uri);
            }
            if (mainFileUri.endsWith('.pde')) {
                const message = nls_1.nls.localize('arduino/common/oldFormat', "The '{0}' still uses the old `.pde` format. Do you want to switch to the new `.ino` extension?", sketch.name);
                const yes = nls_1.nls.localize('vscode/extensionsUtils/yes', 'Yes');
                this.messageService.info(message, nls_2.Later, yes).then((answer) => {
                    if (answer === yes) {
                        this.commandService.executeCommand(save_as_sketch_1.SaveAsSketch.Commands.SAVE_AS_SKETCH.id, {
                            execOnlyIfTemp: false,
                            openAfterMove: true,
                            wipeOriginal: false,
                        });
                    }
                });
            }
            const { workspaceError } = this.workspaceService;
            // This happens when the IDE2 has been started (from either a terminal or clicking on an `ino` file) with a /path/to/invalid/sketch. (#964)
            if (protocol_1.SketchesError.InvalidName.is(workspaceError)) {
                await this.promptMove(workspaceError);
            }
        }
        catch (err) {
            // This happens when the user gracefully closed IDE2, all went well
            // but the main sketch file was renamed outside of IDE2 and when the user restarts the IDE2
            // the workspace path still exists, but the sketch path is not valid anymore. (#964)
            if (protocol_1.SketchesError.InvalidName.is(err)) {
                const movedSketch = await this.promptMove(err);
                if (!movedSketch) {
                    // If user did not accept the move, or move was not possible, force reload with a fallback.
                    return this.openFallbackSketch();
                }
            }
            if (protocol_1.SketchesError.NotFound.is(err)) {
                return this.openFallbackSketch();
            }
            else {
                console.error(err);
                const message = err instanceof Error
                    ? err.message
                    : typeof err === 'string'
                        ? err
                        : String(err);
                this.messageService.error(message);
            }
        }
    }
    async promptMove(err) {
        const { invalidMainSketchUri } = err.data;
        requestAnimationFrame(() => this.messageService.error(err.message));
        await (0, promise_util_1.wait)(10); // let IDE2 toast the error message.
        const movedSketch = await (0, open_sketch_1.promptMoveSketch)(invalidMainSketchUri, {
            fileService: this.fileService,
            sketchService: this.sketchService,
            labelProvider: this.labelProvider,
        });
        if (movedSketch) {
            this.workspaceService.open(new contribution_1.URI(movedSketch.uri), {
                preserveWindow: true,
            });
            return movedSketch;
        }
        return undefined;
    }
    async openFallbackSketch() {
        const sketch = await this.sketchService.createNewSketch();
        this.workspaceService.open(new contribution_1.URI(sketch.uri), { preserveWindow: true });
    }
    async ensureOpened(uri, forceOpen = false, options) {
        const widget = this.editorManager.all.find((widget) => widget.editor.uri.toString() === uri);
        const disposables = new disposable_1.DisposableCollection();
        if (!widget || forceOpen) {
            const deferred = new promise_util_1.Deferred();
            disposables.push(this.editorManager.onCreated((editor) => {
                if (editor.editor.uri.toString() === uri) {
                    if (editor.isVisible) {
                        disposables.dispose();
                        deferred.resolve(editor);
                    }
                    else {
                        // In Theia, the promise resolves after opening the editor, but the editor is neither attached to the DOM, nor visible.
                        // This is a hack to first get an event from monaco after the widget update request, then IDE2 waits for the next monaco context key event.
                        // Here, the monaco context key event is not used, but this is the first event after the editor is visible in the UI.
                        disposables.push(editor.editor.onDidResize((dimension) => {
                            if (dimension) {
                                const isKeyOwner = (arg) => {
                                    if (typeof arg === 'object') {
                                        const object = arg;
                                        return typeof object['key'] === 'string';
                                    }
                                    return false;
                                };
                                disposables.push(this.contextKeyService.onDidChangeContext((e) => {
                                    // `commentIsEmpty` is the first context key change event received from monaco after the editor is for real visible in the UI.
                                    if (isKeyOwner(e) && e.key === 'commentIsEmpty') {
                                        deferred.resolve(editor);
                                        disposables.dispose();
                                    }
                                }));
                            }
                        }));
                    }
                }
            }));
            this.editorManager.open(new contribution_1.URI(uri), options !== null && options !== void 0 ? options : {
                mode: 'reveal',
                preview: false,
                counter: 0,
            });
            const timeout = 5000; // number of ms IDE2 waits for the editor to show up in the UI
            const result = await Promise.race([
                deferred.promise,
                (0, promise_util_1.wait)(timeout).then(() => {
                    disposables.dispose();
                    return 'timeout';
                }),
            ]);
            if (result === 'timeout') {
                console.warn(`Timeout after ${timeout} millis. The editor has not shown up in time. URI: ${uri}`);
            }
            return result;
        }
    }
};
__decorate([
    (0, inversify_1.inject)(contextKeyService_1.ContextKeyService),
    __metadata("design:type", contextKeyService_1.ContextKeyService)
], OpenSketchFiles.prototype, "contextKeyService", void 0);
OpenSketchFiles = OpenSketchFiles_1 = __decorate([
    (0, inversify_1.injectable)()
], OpenSketchFiles);
exports.OpenSketchFiles = OpenSketchFiles;
(function (OpenSketchFiles) {
    let Commands;
    (function (Commands) {
        Commands.OPEN_SKETCH_FILES = {
            id: 'arduino-open-sketch-files',
        };
        Commands.ENSURE_OPENED = {
            id: 'arduino-ensure-opened',
        };
    })(Commands = OpenSketchFiles.Commands || (OpenSketchFiles.Commands = {}));
})(OpenSketchFiles = exports.OpenSketchFiles || (exports.OpenSketchFiles = {}));
exports.OpenSketchFiles = OpenSketchFiles;
//# sourceMappingURL=open-sketch-files.js.map